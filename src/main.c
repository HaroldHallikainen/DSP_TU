/*******************************************************************************
  Main Source File
  Company:
   W6IWI.ORG
  File Name:
    main.c
  Summary:
    This file contains the "main" function for a project.
  Description:
    This file contains the "main" function for a project.  The
    "main" function calls the "SYS_Initialize" function to initialize the state
    machines of all modules in the system
 *******************************************************************************/

// *****************************************************************************
// *****************************************************************************
// Section: Included Files
// *****************************************************************************
// *****************************************************************************

#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include <stdio.h>                      // sprintf, etc.
#include <string.h>                     // strlen, etc.
#include "definitions.h"                // SYS function prototypes
#include "PwmAudioOut.h"                // Convert floating sample to PWM duty cycle
#include "dds.h"                        // Generate next sample via Direct Digital Synthesis
#include "biquad.h"                     // biquad filters. Includes typedef for smp_type
#include "DynamicThreshold.h"           // Calculates threshold based on max mark and space levels
#include "agc.h"                        // Input automatic gain control
#include "main.h"
#include "display.h"
#include "xyScope.h"
#include "AfskGen.h" 
#include "BaudotUart.h"


// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

// Globals 
volatile int16_t Timer2TimeoutCounter=0; // Derive 8 kHz from timer 2 80 kHz
// Audio samples at various stages
uint16_t AdcSample;         // Raw sample from ADC. Converted to AdcSamplef for calculations.
smp_type samplef, TestSamplef, MarkSample, SpaceSample, MarkDemodOut, SpaceDemodOut, DiscrimOut, DdsOut, Threshold;  // These were originally in main but seemed to get corrupted
smp_type MarkFreq=2125.0;
smp_type SpaceFreq=2295.0;
#define NumBpf 2            // How many cascaded BPFs for mark or space 
smp_type BpfQ=18.0;           // Q of individual BPF stage - See https://w6iwi.org/rtty/CascadedBpf.html for overall Q and BW.
smp_type LpfF=50.0;           // Data LPF cutoff frequency - Envelope detection filter
smp_type InputBpfF = 2208.365;     // sqrt Fh*fl
smp_type InputBpfQ = 10;           // Q=10 did not appear to add bias distortion. 20 adds severe bias distortion.
smp_type MarkHoldThresh=0.1;    // Minimum discriminator level to reset mark hold timer.
// What drives the audio output. Usually dds (AFSK tone), but others for debug.  
enum {NONE,ADC, AGC, INPUT_BPF, LIMITER, MARK_FILTER_OUT, SPACE_FILTER_OUT, MARK_DEMOD_OUT, SPACE_DEMOD_OUT, DISCRIM, DDS, THRESHOLD, DISCRIM_LESS_THRESHOLD} AudioOut=DDS;

// Incoming ADC samples converted to smp_type (samplef) then passed thru options to tone filters)
int UseInputBpf=TRUE;
int UseLimiter=FALSE;
int UseAgc=TRUE;
int Shift=170;          // Sets mark and space frequencies
int TxEnable=0;         // test afsk on/off

// #define UseUartDebug
#ifdef UseUartDebug
  char StringBuf[100];
  int DebugCounter=0;
#endif

int main ( void ){
    biquad *MarkFilter[NumBpf]; // Audio BPF for mark (array of pointers for cascaded filters)
    biquad *SpaceFilter[NumBpf]; // Audio BPF for space
    biquad *MarkDataFilter;     // Mark LPF after absolute value "full wave rectification" 
    biquad *SpaceDataFilter;
    biquad *InputBpf;

    int n;
    int MarkHoldTimer=0;        // How long 'til we mark hold
     /* Initialize all modules */
    SYS_Initialize ( NULL );    // Run init code generated by Harmony
    TMR2_Start();               // Timer for 80 kHz PWM output
    OCMP1_Enable();             // PWM generator for audio
    DynamicThresholdInit();     // Set up LPF used in dynamic threshold
    switch(Shift){
      case 850:
        MarkFreq=2.0e3-425.0;   // For 850 Hz shift, center at 2 kHz
        SpaceFreq=2.0e3+425.0;
        break;
      case 170:
      default:
        MarkFreq=2125.0;
        SpaceFreq=2295.0;
        break;
    }
    AgcInit();                  // Set up automatic gain control
    DisplayInit();         // Initialize display and related fifo
    AudioPwmSet(0.0);           // Initialize PWM to 50% duty cycle representing 0.0.
    ADCHS_ChannelConversionStart(4); // Start a first ADC conversion
    for(n=0;n<NumBpf;n++){      // Initialize tone BPFs (array of pointers). 8000.0 is audio sample rate.
      MarkFilter[n] = BiQuad_new(BPF, 0.0, MarkFreq, 8000.0, BpfQ);    
      SpaceFilter[n] = BiQuad_new(BPF, 0.0, SpaceFreq, 8000.0, BpfQ);
    }  
    MarkDataFilter=BiQuad_new(LPF, 0.0, LpfF, 8000.0, 0.707 ); // After rectification data LPF
    SpaceDataFilter=BiQuad_new(LPF, 0.0, LpfF, 8000.0, 0.707 );
    InputBpf=BiQuad_new(BPF,0.0,(smp_type)sqrt((double)(MarkFreq*SpaceFreq)), 8000.0, InputBpfQ);
    AfskGenInit();      // Initialize a low pass filter between loop current sample and DDS.
    DisplayClear();
    while ( true ){
      if(Timer2TimeoutCounter<1){        // We have timed out 10 times, so it has been 125 us
        CPU_IDLEn_Set();                  // CPU not idle, so set RE7 so we can time it  
        Timer2TimeoutCounter+=10;    // come back in 125 us. PWM frequency is 80 kHz, so change every 10 cycles
        if(1){ //if(ADCHS_ChannelResultIsReady(4)){ // ADC has sample
          AdcSample=ADCHS_ChannelResultGet(4);      // Get sample as uint16_t
          samplef=(smp_type)(AdcSample-2048)/2048.0;   // Convert to smp_type with mid-scale=0.0
          ADCHS_ChannelConversionStart(4);              // Start next ADC conversion
        }                                               // endif ADC ready
        AfskGen();              // Adjust DDS frequency based on loop condition
        DdsOut=DdsNextSample(); // Run DDS tone generator
        TestSamplef=0.0;                // Output silence if nothing selected
        if(AudioOut==ADC) TestSamplef=samplef;
        if(UseInputBpf==TRUE){
            samplef=BiQuad(samplef,InputBpf);
        }
        if(AudioOut==INPUT_BPF) TestSamplef=samplef;
        if(UseAgc==TRUE){
          samplef=agc(samplef);
        }
        if(AudioOut==AGC) TestSamplef=samplef;
        if(UseLimiter==TRUE){                            // Use limiter or pass input to output
          samplef=(smp_type)copysign(1.0,(double)samplef);            // Limiter. Returns 1.0 if sample positive, =1.0 if negative
        }
        if(AudioOut==LIMITER) TestSamplef=samplef;
        MarkSample=samplef;                         
        SpaceSample=samplef;
        for(n=0;n<NumBpf;n++){
          MarkSample=BiQuad(MarkSample,MarkFilter[n]);       // Mark BPF
          SpaceSample=BiQuad(SpaceSample,SpaceFilter[n]);     // Space BPF
        }
        xyScope(MarkSample,SpaceSample);
        if(AudioOut==MARK_FILTER_OUT) TestSamplef=MarkSample;
        if(AudioOut==SPACE_FILTER_OUT) TestSamplef=SpaceSample;
        MarkDemodOut=BiQuad(fabs(MarkSample), MarkDataFilter);  // Envelope detected and filtered mark
        SpaceDemodOut=BiQuad(fabs(SpaceSample), SpaceDataFilter);    // Same for space
        if(AudioOut==MARK_DEMOD_OUT) TestSamplef=MarkDemodOut;
        if(AudioOut==SPACE_DEMOD_OUT) TestSamplef=SpaceDemodOut;
               // DiscrimOut is difference between LPF of full wave rectified of mark and space BPFs
        DiscrimOut=MarkDemodOut-SpaceDemodOut;
        if(DiscrimOut>MarkHoldThresh){  // we have mark instead of space or noise
          MarkHoldTimer=2400;         // Allow loop key for another 300ms. One character is 163ms long
        }else{
          if(MarkHoldTimer>0) MarkHoldTimer--;
        }    
        if(AudioOut==DISCRIM) TestSamplef=DiscrimOut;
        Threshold=DynamicThresholdGet(MarkDemodOut, SpaceDemodOut);
        if(AudioOut==THRESHOLD) TestSamplef=Threshold;
        if(AudioOut==DISCRIM_LESS_THRESHOLD) TestSamplef=DiscrimOut-Threshold;
        if(MarkHoldTimer>0){     // Not in mark hold, key loop
          if((DiscrimOut-Threshold)>=0){      // Mark
            LOOP_KEY_OUT_Set();     // Loop switch on
            LED_GREENn_Clear();     // light green LED
            LED_REDn_Set();     // red LED off
          }else{                  // Space
            LOOP_KEY_OUT_Clear();     // Loop switch off
            LED_GREENn_Set();     // green LED off
            LED_REDn_Clear();     // red LED on
          } 
        }else{
          LOOP_KEY_OUT_Set();     // Mark hold timed out, so hold mark
        }    
        if(AudioOut==DDS) TestSamplef=DdsOut;
        AudioPwmSet(TestSamplef);   // Output selected test signal
        // Debug output as CSV
        #ifdef UseUartDebug
          if(0==DebugCounter--){       // output debug data  // To output every 1 ms, run this every 8 samples
            sprintf(StringBuf,"%E\r\n",DiscrimOut);
            UART2_Write((uint8_t*)StringBuf,strlen(StringBuf));   // Cast to uint_8. Sprintf outputs int8 while UART2_Write takes uint8
            DebugCounter=16;              // Come back in 16 samples (2 ms)
          }
        #endif
        if(TxEnable==1){
            AFSK_OUT_ENn_Clear();
        }else{
          AFSK_OUT_ENn_Set();
        }
        BaudotUartRx();
      } // endif Timer2TimeoutCounter
      DisplayPoll();            // If something in display fifo, send it
      CPU_IDLEn_Clear();      // Exiting DSP code, so make RE7 low so we can see how much time spent there.   
      /* Maintain state machines of all polled MPLAB Harmony modules. */
      SYS_Tasks ( );
    }  // end while(true))
    /* Execution should not come here during normal operation */
    return ( EXIT_FAILURE );
  }  // end main())


/*******************************************************************************
 End of File
*/

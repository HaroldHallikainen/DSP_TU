/*******************************************************************************
  Main Source File
  Company:
   W6IWI.ORG
  File Name:
    main.c
  Summary:
    This file contains the "main" function for a project.
  Description:
    This file contains the "main" function for a project.  The
    "main" function calls the "SYS_Initialize" function to initialize the state
    machines of all modules in the system
 *******************************************************************************/

// *****************************************************************************
// *****************************************************************************
// Section: Included Files
// *****************************************************************************
// *****************************************************************************

#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include <stdio.h>                      // sprintf, etc.
#include <string.h>                     // strlen, etc.
#include "definitions.h"                // SYS function prototypes
#include "PwmAudioOut.h"                // Convert floating sample to PWM duty cycle
#include "dds.h"                        // Generate next sample via Direct Digital Synthesis
#include "biquad.h"                     // biquad filters
#include "DynamicThreshold.h"           // Calculates threshold based on max mark and space levels
#include "agc.h"                        // Input automatic gain control
#include "main.h"

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

// Globals 
volatile uint16_t Timer2TimeoutCounter=0; // Derive 8 kHz from timer 2 80 kHz
// Audio samples at various stages
double samplef, TestSamplef, MarkSample, SpaceSample, MarkDemodOut, SpaceDemodOut, DiscrimOut, DdsOut, Threshold;  // These were originally in main but seemed to get corrupted
double MarkFreq=2125.0;
double SpaceFreq=2295.0;
#define NumBpf 2            // How many cascaded BPFs for mark or space 
double BpfQ=18.0;           // Q of individual BPF stage - See https://w6iwi.org/rtty/CascadedBpf.html for overall Q and BW.
double LpfF=50.0;           // Data LPF cutoff frequency - Envelope detection filter
double InputBpfF = 2208.365;     // sqrt Fh*fl
double InputBpfQ = 10;           // Q=10 did not appear to add bias distortion. 20 adds severe bias distortion.
// What drives the audio output. Usually dds (AFSK tone), but others for debug.  
enum {NONE,ADC, AGC, INPUT_BPF, LIMITER, MARK_FILTER_OUT, SPACE_FILTER_OUT, MARK_DEMOD_OUT, SPACE_DEMOD_OUT, DISCRIM, DDS, THRESHOLD, DISCRIM_LESS_THRESHOLD} AudioOut=DISCRIM_LESS_THRESHOLD;

// Incoming ADC samples converted to double (samplef) then passed thru options to tone filters)
int UseInputBpf=TRUE;
int UseLimiter=FALSE;
int UseAgc=TRUE;


int main ( void ){
    biquad *MarkFilter[NumBpf]; // Audio BPF for mark (array of pointers for cascaded filters)
    biquad *SpaceFilter[NumBpf]; // Audio BPF for space
    biquad *MarkDataFilter;     // Mark LPF after absolute value "full wave rectification" 
    biquad *SpaceDataFilter;
    biquad *InputBpf;
    uint16_t AdcSample;         // Raw sample from ADC. Converted to AdcSamplef for calculations.
    double DdsFreq=100.0;       
    int n;
    /* Initialize all modules */
    SYS_Initialize ( NULL );    // Run init code generated by Harmony
    TMR2_Start();               // Timer for 80 kHz PWM output
    OCMP1_Enable();             // PWM generator for audio
    DynamicThresholdInit();     // Set up LPF used in dynamic threshold
    AgcInit();                  // Set up automatic gain control
    AudioPwmSet(0.0);           // Initialize PWM to 50% duty cycle representing 0.0.
    ADCHS_ChannelConversionStart(4); // Start a first ADC conversion
    for(n=0;n<NumBpf;n++){      // Initialize tone BPFs (array of pointers). 8000.0 is audio sample rate.
      MarkFilter[n] = BiQuad_new(BPF, 0.0, MarkFreq, 8000.0, BpfQ);    
      SpaceFilter[n] = BiQuad_new(BPF, 0.0, SpaceFreq, 8000.0, BpfQ);
    }  
    MarkDataFilter=BiQuad_new(LPF, 0.0, LpfF, 8000.0, 0.707 ); // After rectification data LPF
    SpaceDataFilter=BiQuad_new(LPF, 0.0, LpfF, 8000.0, 0.707 );
    InputBpf=BiQuad_new(BPF,0.0,InputBpfF, 8000.0, InputBpfQ);
    while ( true ){
      if(Timer2TimeoutCounter==0){        // We have timed out 10 times, so it has been 125 us
        CPU_IDLEn_Set();                  // CPU not idle, so set RE7 so we can time it  
        if(ADCHS_ChannelResultIsReady(4)){ // ADC has sample
          AdcSample=ADCHS_ChannelResultGet(4);      // Get sample as UINT16
          samplef=(double)(AdcSample-2048)/2048.0;   // Convert to double with mid-scale=0.0
          ADCHS_ChannelConversionStart(4);              // Start next ADC conversion
        }                                               // endif ADC ready
        // Tone Sweep TEST
        DdsFreq*=1.00001;
        if(DdsFreq>2295.0) DdsFreq=2125.0;
        DdsFreqSet(DdsFreq); 
        // End tone sweep
        TestSamplef=0.0;                // Output silence if nothing selected
        if(AudioOut==ADC) TestSamplef=samplef;
        if(UseInputBpf==TRUE){
            samplef=BiQuad(samplef,InputBpf);
        }
        if(AudioOut==INPUT_BPF) TestSamplef=samplef;
        if(UseAgc==TRUE){
          samplef=agc(samplef);
        }
        if(AudioOut==AGC) TestSamplef=samplef;
        if(UseLimiter==TRUE){                            // Use limiter or pass input to output
          samplef=copysign(1.0,samplef);            // Limiter. Returns 1.0 if sample positive, =1.0 if negative
        }
        if(AudioOut==LIMITER) TestSamplef=samplef;
        MarkSample=samplef;                         
        SpaceSample=samplef;
        for(n=0;n<NumBpf;n++){
          MarkSample=BiQuad(MarkSample,MarkFilter[n]);       // Mark BPF
          SpaceSample=BiQuad(SpaceSample,SpaceFilter[n]);     // Space BPF
        }
        if(AudioOut==MARK_FILTER_OUT) TestSamplef=MarkSample;
        if(AudioOut==SPACE_FILTER_OUT) TestSamplef=SpaceSample;
        MarkDemodOut=BiQuad(fabs(MarkSample), MarkDataFilter);  // Envelope detected and filtered mark
        SpaceDemodOut=BiQuad(fabs(SpaceSample), SpaceDataFilter);    // Same for space
        if(AudioOut==MARK_DEMOD_OUT) TestSamplef=MarkDemodOut;
        if(AudioOut==SPACE_DEMOD_OUT) TestSamplef=SpaceDemodOut;
               // DiscrimOut is difference between LPF of full wave rectified of mark and space BPFs
        DiscrimOut=MarkDemodOut-SpaceDemodOut;
        if(AudioOut==DISCRIM) TestSamplef=DiscrimOut;
        Threshold=DynamicThresholdGet(MarkDemodOut, SpaceDemodOut);
        if(AudioOut==THRESHOLD) TestSamplef=Threshold;
        if(AudioOut==DISCRIM_LESS_THRESHOLD) TestSamplef=DiscrimOut-Threshold;
        if((DiscrimOut-Threshold)>=0){      // Mark
          LOOP_KEY_OUT_Set();     // Loop switch on
          LED_GREENn_Clear();     // light green LED
          LED_REDn_Set();     // red LED off
        }else{                  // Space
          LOOP_KEY_OUT_Clear();     // Loop switch off
          LED_GREENn_Set();     // green LED off
          LED_REDn_Clear();     // red LED on
        }
        DdsOut=DdsNextSample(); // Run DDS tone generator
        if(AudioOut==DDS) TestSamplef=DdsOut;
        AudioPwmSet(TestSamplef);   // Output selected test signal
        Timer2TimeoutCounter=10;    // come back in 125 us. PWM frequency is 80 kHz, so change every 10 cycles
        // Debug output as CSV
//        if(0==DebugCounter--){       // output debug data  // To output every 1 ms, run this every 8 samples
//          sprintf(StringBuf,"%E, %E\r\n",MarkDemodOut,SpaceDemodOut);
//          UART2_Write((uint8_t*)StringBuf,strlen(StringBuf));   // Cast to uint_8. Sprintf outputs int8 while UART2_Write takes uint8
//          DebugCounter=16;              // Come back in 16 samples (2 ms)
//        }
        CPU_IDLEn_Clear();      // Exiting DSP code, so make RE7 low so we can see how much time spent there.   
      } // endif Timer2TimeoutCounter
      /* Maintain state machines of all polled MPLAB Harmony modules. */
      SYS_Tasks ( );
    }  // end while(true))
    /* Execution should not come here during normal operation */
    return ( EXIT_FAILURE );
  }  // end main())


/*******************************************************************************
 End of File
*/
